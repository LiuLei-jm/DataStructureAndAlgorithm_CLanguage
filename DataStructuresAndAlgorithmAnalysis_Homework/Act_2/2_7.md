(a) 显然三种算法都生成合法的置换，前两种算法有确保不会发生数字重复的检测，第三种算法时打乱一个原本就没有重复的数组，所以三种都不会生成不合法的置换。前两种算法时完全随机的，每种置换都是等可能的。而这一点对第三种算法（它由R.Floyd提出）不是很显然，这一算法的正确性可以通过数学归纳法证明，读者可参阅Jon Bentley的《Programming Pearls》(《编程珠玑》)<br/>
需要指出的是若算法3的第二行改为<br/>
Swap(A[i],A[RandInt(0,N-1)]);<br/>
则各置换并不随机出现。为了说明这一点，注意到当N=3时，共有27种等可能的交换方式，而合法的置换由6种，无法平分27，因此若算法时如此，每种置换不会等可能出现。<br/>
(b) 第一种算法，判断在A[i]位置随机生成的数是否与前面的重复需要耗费O(i)时间，产生随机数个数的数学期望为N(N-i)，这个值由如下的步骤得出：N个数中有i个是与前面重复的，所以产生一个不重复的数字的概率是(N-i)/N，且每次的结果互相独立，因此平均需要N/(N-i)次尝试才能产生不重复的数字，所有时间界为<br/>
第二种算法节省了可能出现的i次测试，所以时间界降为O(NlogN),第三种算法很明显是线性的。<br/>
(c,d) 如果有足够的空间，运行结果会和上述的分析一致，如果没有足够的空间，第三个算法当N很大时会有激烈的增长，使它看起来不是线性的。<br/>
(e) 无法为第一、二种算法的最坏运行时间找到一个界，因为对任意给定的时间T，算法结束的概率都不为0（虽然如此，算法使一定会结束的）。第三种算法的最坏运行时间仍是线性的，它的运行时间不依赖与产生的随机数序列。